---
title: 'Building Autonomous AI Agents with Python and LangChain'
slug: 'ai-agents-python-langchain-tutorial'
publishedAt: '2025-01-18'
summary: 'Complete tutorial on how to create AI agents that can use tools, make decisions, and execute complex tasks autonomously using Python and LangChain.'
translations:
  pt: 'agentes-ia-python-langchain-tutorial'
---

## Why AI Agents Are the Future

After working with LLMs for months, I realized a fundamental limitation: they only respond. They can't browse the web, query APIs, or execute code. AI agents completely change this game.

In this article, I'll show how I built an agent that can:
- Search for information on the internet
- Perform mathematical calculations
- Query APIs
- Make decisions based on results

## What Are AI Agents?

An AI agent is a system that can:
1. **Observe**: Understand the question/task
2. **Think**: Decide which actions to take
3. **Act**: Execute actions using tools
4. **Learn**: Adjust based on results

### Anatomy of an Agent

```
Input → [LLM Brain] → Decision → Tool → Result → [LLM Brain] → Output
                ↑                                                    ↓
                └────────────────── Loop until complete ─────────────┘
```

## Building Your First Agent

### Step 1: Environment Setup

```bash
pip install langchain langchain-openai langchain-community
pip install google-search-results
pip install numexpr
```

### Step 2: Creating Basic Tools

```python
from langchain.agents import Tool
from langchain.tools import DuckDuckGoSearchRun
from langchain.utilities import WikipediaAPIWrapper

# Search tool
search = DuckDuckGoSearchRun()
search_tool = Tool(
    name="Web Search",
    func=search.run,
    description="Useful for searching current information on the internet."
)

# Wikipedia tool
wikipedia = WikipediaAPIWrapper()
wiki_tool = Tool(
    name="Wikipedia",
    func=wikipedia.run,
    description="Useful for getting detailed information about general topics."
)
```

**Important lesson**: Each tool's description is crucial. The LLM uses these descriptions to decide which tool to use.

### Step 3: Creating a Custom Tool

```python
import requests

def get_crypto_price(crypto: str) -> str:
    try:
        crypto = crypto.strip().upper()
        url = "https://api.coincap.io/v2/assets/" + crypto.lower()
        response = requests.get(url)
        data = response.json()

        if 'data' in data:
            price = float(data['data']['priceUsd'])
            return "Current price of " + crypto + ": $" + str(round(price, 2)) + " USD"
        return "Couldn't find information for " + crypto
    except Exception as e:
        return "Error fetching price: " + str(e)

crypto_tool = Tool(
    name="Crypto Price",
    func=get_crypto_price,
    description="Gets the current price of cryptocurrencies. Input: crypto symbol (e.g., BTC, ETH, SOL)"
)
```

### Step 4: Assembling the Agent

```python
from langchain.agents import AgentExecutor, create_react_agent
from langchain_openai import ChatOpenAI
from langchain import hub

# LLM Model
llm = ChatOpenAI(
    model="gpt-4-turbo-preview",
    temperature=0
)

# Tools list
tools = [search_tool, wiki_tool, crypto_tool]

# Agent prompt (ReAct pattern)
prompt = hub.pull("hwchase17/react")

# Create agent
agent = create_react_agent(llm, tools, prompt)

# Agent executor
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=True,
    max_iterations=5,
    handle_parsing_errors=True
)
```

### Step 5: Testing the Agent

```python
# Test 1: Simple search
result = agent_executor.invoke({
    "input": "What is the current price of Bitcoin?"
})
print(result["output"])

# Test 2: Multiple tools
result = agent_executor.invoke({
    "input": "Find the price of Ethereum and calculate how much 5 ETH would be in dollars"
})
print(result["output"])
```

**Real output**:

```
> Entering new AgentExecutor chain...

Thought: I need to find the price of Ethereum

Action: Crypto Price
Action Input: ETH

Observation: Current price of ETH: $2,456.78 USD

Thought: Now I need to multiply by 5

Final Answer: The current price of Ethereum is $2,456.78 USD.
Therefore, 5 ETH is worth $12,283.90 USD.

> Finished chain.
```

## Agent Patterns

### 1. ReAct (Reasoning + Acting)

The agent:
- **Thinks** (Thought)
- **Acts** (Action)
- **Observes** (Observation)
- **Repeats** until it has the answer

### 2. Plan-and-Execute

For more complex tasks, the agent first creates a complete plan and then executes each step.

### 3. Auto-GPT Style

Fully autonomous agent with long-term memory.

## Best Practices

### 1. Limit Iterations

```python
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    max_iterations=10,  # ALWAYS define
    early_stopping_method="generate"
)
```

### 2. Handle Errors Gracefully

```python
def safe_tool_wrapper(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            return "Error: " + str(e) + ". Try another approach."
    return wrapper
```

### 3. Monitor Costs

```python
from langchain.callbacks import get_openai_callback

with get_openai_callback() as cb:
    result = agent_executor.invoke({"input": "Your question"})
    print("Tokens used:", cb.total_tokens)
    print("Cost: $", cb.total_cost)
```

## Challenges Faced

### Challenge 1: Agent Gets Confused

**Solution**: I improved tool descriptions with clear examples of when to use each one.

### Challenge 2: High Costs

**Solution**:
- Used GPT-3.5-turbo for simple tasks
- Implemented aggressive caching
- Limited iterations

### Challenge 3: Reliability

**Solution**: Implemented retry with exponential backoff:

```python
from tenacity import retry, stop_after_attempt

@retry(stop=stop_after_attempt(3))
def reliable_agent_run(query: str):
    return agent_executor.invoke({"input": query})
```

## Production Results

Real metrics:
- Success rate: 85%
- Average time: 8 seconds
- Cost per execution: $0.05
- 60% reduction in simple support tickets

## Conclusion

AI agents open up incredible possibilities. The key is:
- Well-described tools
- Appropriate limits
- Constant monitoring
- Iteration based on feedback

Questions? Leave them in the comments!
